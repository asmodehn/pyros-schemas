from __future__ import absolute_import
from __future__ import print_function

"""
Defining Schema for basic ros types


These are used when converting a Ros Message (as a type generated by genmsg) to dict, string, json, etc. and also python.

From wiki.ros.org/msg :
Primitive Type    | Serialization                     | C++           | Python
------------------------------------------------------------------------------
string            | ascii string (4)                  | std::string   | str

Array handling:
Array Type        |   Serialization           |  C + +                                        |  Python
-------------------------------------------------------------------------------------------------------
fixed - length    | no extra serialization    | 0.11 +: boost::array, otherwise: std::vector  | tuple(1)
variable - length | uint32 length prefix      | std::vector                                   | tuple(1)

In rospy, arrays are deserialized as tuples for performance reasons, but you can set fields to tuples and lists interchangeably.

Detailed Ref : http://wiki.ros.org/std_msgs


These Fields and Schema are meant to be used together with ROS message type serialization :
ROSTCP --deserialize in rospy--> std_msgs.msg.String --serialize (dump) in pyros_schemas--> dict
And reversely :
dict --deserialize (load) in pyros_schemas--> std_msgs.msg.String --serialize in rospy--> ROSTCP

This helps pyros deal with data only as dicts without worrying about the underlying ROS implementation.
Also some serialization behavior adjustments have been done :

- optional fields

"""

try:
    import std_msgs.msg as std_msgs
except ImportError:
    # Because we need to access Ros message types here (from ROS env or from virtualenv, or from somewhere else)
    import pyros_setup
    # We rely on default configuration to point us to the proper distro
    pyros_setup.configurable_import().configure().activate()
    import std_msgs.msg as std_msgs


# This is useful only if we need relative imports. Ref : http://stackoverflow.com/a/28154841/4006172
# declaring __package__ if needed (this module is run individually)
if __package__ is None and not __name__.startswith('pyros_schemas.'):
    import sys
    from pathlib2 import Path
    top = Path(__file__).resolve().parents[1]
    sys.path.append(str(top))
    # Or
    # from os.path import abspath, dirname
    #
    # top = abspath(__file__)
    # for _ in range(4):
    #     top = dirname(top)
    # sys.path.append(top)

    import pyros_schemas
    __package__ = 'pyros_schemas'

# To be able to run doctest directly we avoid relative import
from .decorators import with_explicitly_matched_type

import marshmallow

# Both pyros and rospy serialization could eventually be combined, to serialize only once and get a dict.
# TODO : investigate
# KISS as much as possible for now



@with_explicitly_matched_type(std_msgs.String)
class RosMsgString(marshmallow.Schema):
    """
    RosMsgString handles serialization from std_msgs.String to python dict
    and deserialization from python dict to std_msgs.String

    You should use strict Schema to trigger exceptions when trying to manipulate an unexpected type.

    >>> schema = RosMsgString(strict=True)

    >>> rosmsgFortytwo = std_msgs.String(data='fortytwo')
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    >>> marshmallow.pprint(marshalledFortytwo) if not errors else print("ERRORS {0}".format(errors))
    {u'data': u'fortytwo'}
    >>> value, errors = schema.load(marshalledFortytwo)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._String.String'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))
    data: fortytwo

    Invalidate message would report:
    >>> rosmsgFortytwo = std_msgs.UInt16(data=42)
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    Traceback (most recent call last):
     ...
    ValidationError: data type should be <class 'std_msgs.msg._String.String'>

    Load is the inverse of dump (getting only data member):
    >>> import random
    >>> randomRosString = std_msgs.String(random.choice(['four', 'two', 'one']))
    >>> schema.load(schema.dump(randomRosString).data).data == randomRosString
    True
    """
    data = RosFieldString()

