from __future__ import absolute_import
from __future__ import print_function

"""
Defining Schema for basic ros types


These are used when converting a Ros Message (as a type generated by genmsg) to dict, string, json, etc. and also python.

From wiki.ros.org/msg :
Primitive Type    | Serialization                     | C++           | Python
------------------------------------------------------------------------------
duration          | secs/nsecs signed 32-bit ints     | ros::Duration | rospy.Duration

Array handling:
Array Type        |   Serialization           |  C + +                                        |  Python
-------------------------------------------------------------------------------------------------------
fixed - length    | no extra serialization    | 0.11 +: boost::array, otherwise: std::vector  | tuple(1)
variable - length | uint32 length prefix      | std::vector                                   | tuple(1)

In rospy, arrays are deserialized as tuples for performance reasons, but you can set fields to tuples and lists interchangeably.

Detailed Ref : http://wiki.ros.org/std_msgs


These Fields and Schema are meant to be used together with ROS message type serialization :
ROSTCP --deserialize in rospy--> std_msgs.msg.Duration --serialize (dump) in pyros_schemas--> dict
And reversely :
dict --deserialize (load) in pyros_schemas--> std_msgs.msg.Duration --serialize in rospy--> ROSTCP

This helps pyros deal with data only as dicts without worrying about the underlying ROS implementation.
Also some serialization behavior adjustments have been done :

- optional fields

"""


import marshmallow
try:
    import std_msgs.msg as std_msgs
    import genpy
except ImportError:
    # Because we need to access Ros message types here (from ROS env or from virtualenv, or from somewhere else)
    import pyros_setup
    # We rely on default configuration to point us to the proper distro
    pyros_setup.configurable_import().configure().activate()
    import std_msgs.msg as std_msgs
    import genpy


# To be able to run doctest directly we avoid relative import
from .decorators import with_explicitly_matched_type

from .std_Int import RosFieldInt32

# Both pyros and rospy serialization could eventually be combined, to serialize only once and get a dict.
# TODO : investigate
# KISS as much as possible for now


# this can be a field for Ros definition, but is actually a schema that need to match rostime
@with_explicitly_matched_type(genpy.rostime.Duration)
class RosFieldDuration(marshmallow.Schema):
    secs = RosFieldInt32()
    nsecs = RosFieldInt32()


#
# Schemas declaration
# Since we want to provide seamless but safe rospy message type <-> pyros dict conversion
# We need to validate on serialization (dump to dict)
# and create a rospy message type on deserialization (load from dict)
#


@with_explicitly_matched_type(std_msgs.Duration)
class RosMsgDuration(marshmallow.Schema):
    """
    RosMsgTime handles serialization from std_msgs.Time to python dict
    and deserialization from python dict to std_msgs.Time

    You should use strict Schema to trigger exceptions when trying to manipulate an unexpected type.

    >>> schema = RosMsgDuration(strict=True)

    >>> rosmsgFourtwo = std_msgs.Duration()
    >>> rosmsgFourtwo.data.secs = 42
    >>> rosmsgFourtwo.data.nsecs = 123456789
    >>> marshalledFourtwo, errors = schema.dump(rosmsgFourtwo)
    >>> marshmallow.pprint(marshalledFourtwo) if not errors else print("ERRORS {0}".format(errors))
    {u'data': {u'nsecs': 123456789, u'secs': 42}}
    >>> value, errors = schema.load(marshalledFourtwo)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._Duration.Duration'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))  # doctest: +NORMALIZE_WHITESPACE
    data:
      secs: 42
      nsecs: 123456789

    Load is the inverse of dump (getting only data member):
    >>> import random
    >>> randomRosDuration = std_msgs.Duration()
    >>> randomRosDuration.data.secs = random.choice([4, 2, 1])
    >>> randomRosDuration.data.nsecs = random.choice([123, 456, 789])
    >>> schema.load(schema.dump(randomRosDuration).data).data == randomRosDuration
    True
    """
    data = marshmallow.fields.Nested(RosFieldDuration)

