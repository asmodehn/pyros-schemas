from __future__ import absolute_import
from __future__ import print_function

"""
Defining Schema for basic ros types


These are used when converting a Ros Message (as a type generated by genmsg) to dict, string, json, etc. and also python.

From wiki.ros.org/msg :
Primitive Type    | Serialization                     | C++           | Python
------------------------------------------------------------------------------
float32           | 32-bit IEEE float                 | float         | float
float64           | 64-bit IEEE float                 | double        | float

Array handling:
Array Type        |   Serialization           |  C + +                                        |  Python
-------------------------------------------------------------------------------------------------------
fixed - length    | no extra serialization    | 0.11 +: boost::array, otherwise: std::vector  | tuple(1)
variable - length | uint32 length prefix      | std::vector                                   | tuple(1)

In rospy, arrays are deserialized as tuples for performance reasons, but you can set fields to tuples and lists interchangeably.

Detailed Ref : http://wiki.ros.org/std_msgs


These Fields and Schema are meant to be used together with ROS message type serialization :
ROSTCP --deserialize in rospy--> std_msgs.msg.Float[32/64] --serialize (dump) in pyros_msgs--> dict
And reversely :
dict --deserialize (load) in pyros_msgs--> std_msgs.msg.Float[32/64] --serialize in rospy--> ROSTCP

This helps pyros deal with data only as dicts without worrying about the underlying ROS implementation.
Also some serialization behavior adjustments have been done :

- optional fields

"""


import marshmallow
try:
    import std_msgs.msg as std_msgs
except ImportError:
    # Because we need to access Ros message types here (from ROS env or from virtualenv, or from somewhere else)
    import pyros_setup
    # We rely on default configuration to point us to the proper distro
    pyros_setup.configurable_import().configure().activate()
    import std_msgs.msg as std_msgs


# To be able to run doctest directly we avoid relative import
from .decorators import with_explicitly_matched_type

# Both pyros and rospy serialization could eventually be combined, to serialize only once and get a dict.
# TODO : investigate
# KISS as much as possible for now

#
# Fields declaration
# Since the rospy message type member field is already a python int,
# we do not need anything special here, we rely on marshmallow python type validation.
# Yet we are specifying each on in case we want to extend it later...
#

RosFieldFloat32 = marshmallow.fields.Float
RosFieldFloat64 = marshmallow.fields.Float


#
# Schemas declaration
# Since we want to provide seamless but safe rospy message type <-> pyros dict conversion
# We need to validate on serialization (dump to dict)
# and create a rospy message type on deserialization (load from dict)
#

@with_explicitly_matched_type(std_msgs.Float32)
class RosMsgFloat32(marshmallow.Schema):
    """
    RosMsgFloat32 handles serialization from std_msgs.Float32 to python dict
    and deserialization from python dict to std_msgs.Float32

    You should use strict Schema to trigger exceptions when trying to manipulate an unexpected type.

    >>> schema = RosMsgFloat32(strict=True)

    >>> rosmsgFourtwo = std_msgs.Float32(data=4.2)
    >>> marshalledFourtwo, errors = schema.dump(rosmsgFourtwo)
    >>> marshmallow.pprint(marshalledFourtwo) if not errors else print("ERRORS {0}".format(errors))
    {u'data': 4.2}
    >>> value, errors = schema.load(marshalledFourtwo)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._Float32.Float32'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))
    data: 4.2

    Invalidate message would report:
    >>> rosmsgFortytwo = std_msgs.UInt16(data=42)
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    Traceback (most recent call last):
     ...
    ValidationError: data type should be <class 'std_msgs.msg._Float32.Float32'>

    Load is the inverse of dump (getting only data member):
    >>> import random
    >>> randomRosFloat = std_msgs.Float32(random.choice([4.2, 2.1, 1.0]))
    >>> schema.load(schema.dump(randomRosFloat).data).data == randomRosFloat
    True
    """
    data = RosFieldFloat32()


@with_explicitly_matched_type(std_msgs.Float64)
class RosMsgFloat64(marshmallow.Schema):
    """
    RosMsgFloat64 handles serialization from std_msgs.Float64 to python dict
    and deserialization from python dict to std_msgs.Float64

    You should use strict Schema to trigger exceptions when trying to manipulate an unexpected type.

    >>> schema = RosMsgFloat64(strict=True)

    >>> rosmsgFourtwo = std_msgs.Float64(data=4.2)
    >>> marshalledFourtwo, errors = schema.dump(rosmsgFourtwo)
    >>> marshmallow.pprint(marshalledFourtwo) if not errors else print("ERRORS {0}".format(errors))
    {u'data': 4.2}
    >>> value, errors = schema.load(marshalledFourtwo)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._Float64.Float64'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))
    data: 4.2

    Invalidate message would report:
    >>> rosmsgFortytwo = std_msgs.UInt16(data=42)
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    Traceback (most recent call last):
     ...
    ValidationError: data type should be <class 'std_msgs.msg._Float64.Float64'>

    Load is the inverse of dump (getting only data member):
    >>> import random
    >>> randomRosFloat = std_msgs.Float64(random.choice([4.2, 2.1, 1.0]))
    >>> schema.load(schema.dump(randomRosFloat).data).data == randomRosFloat
    True
    """
    data = RosFieldFloat64()
