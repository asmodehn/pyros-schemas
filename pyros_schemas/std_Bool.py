from __future__ import absolute_import
from __future__ import print_function

"""
Defining Schema for basic ros types


These are used when converting a Ros Message (as a type generated by genmsg) to dict, string, json, etc. and also python.

From wiki.ros.org/msg :
Primitive Type    | Serialization                     | C++           | Python
------------------------------------------------------------------------------
bool (1)          | unsigned 8-bit int                | uint8_t (2)   | bool

bool was introduced in ROS 0.9
bool in C + + is aliased to uint8_t because of array types: std::vector < bool > is in fact a specialized form of vector that is not a container.See http: // www.open - std.org / jtc1 / sc22 / wg21 / docs / papers / 2007 / n2160.html for more information.
uint8 has special meaning in Python.uint8[] is treated as a Python bytes so that it is compatible with other byte-oriented APIs in Python.
unicode strings are currently not supported as a ROS data type.utf - 8 should be used to be compatible with ROS string serialization.In python 2, this encoding is automatic for unicode objects, but decoding must be done manually.In python 3, both encoding and decoding are automatic.

Deprecated:
char: deprecated alias for uint8
byte: deprecated alias for int8

Array handling:
Array Type        |   Serialization           |  C + +                                        |  Python
-------------------------------------------------------------------------------------------------------
fixed - length    | no extra serialization    | 0.11 +: boost::array, otherwise: std::vector  | tuple(1)
variable - length | uint32 length prefix      | std::vector                                   | tuple(1)
uint8[]           | see above                 |  as above                                     | bytes(2)
bool[]            | see above                 | std::vector < uint8_t >                       | list of bool

In rospy, arrays are deserialized as tuples for performance reasons, but you can set fields to tuples and lists interchangeably.
rospy treats uint8[] data as a bytes, which is the Python representation for byte data.In Python 2, this is the same as str.


Detailed Ref : http://wiki.ros.org/std_msgs

These Fields and Schema are meant to be used together with ROS message type serialization :
ROSTCP --deserialize in rospy--> std_msgs.msg.* --serialize (dump) in pyros_schemas--> dict
And reversely :
dict --deserialize (load) in pyros_schemas--> std_msgs.msg.* --serialize in rospy--> ROSTCP

This helps pyros deal with data only as dicts without worrying about the underlying ROS implementation.
Also some serialization behavior adjustments have been done :

- optional fields

"""

import marshmallow
try:
    import std_msgs.msg as std_msgs
except ImportError:
    # Because we need to access Ros message types here (from ROS env or from virtualenv, or from somewhere else)
    import pyros_setup
    # We rely on default configuration to point us to the proper distro
    pyros_setup.configurable_import().configure().activate()
    import std_msgs.msg as std_msgs


# To be able to run doctest directly we avoid relative import
from .decorators import with_explicitly_matched_type

# Keeping field declaration separate in case we want to extend it later
RosFieldBool = marshmallow.fields.Boolean


@with_explicitly_matched_type(std_msgs.Bool)
class RosMsgBool(marshmallow.Schema):
    """
    RosMsgBool Schema handles serialization from std_msgs.msgs.Bool to python dict
    and deserialization from python dict to std_msgs.msgs.Bool

    >>> schema = RosMsgBool()

    >>> rosmsgTrue = std_msgs.Bool(data=True)
    >>> marshalledTrue, errors = schema.dump(rosmsgTrue)
    >>> marshmallow.pprint(marshalledTrue) if not errors else print("ERRORS {0}".format(errors))
    {u'data': True}
    >>> value, errors = schema.load(marshalledTrue)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._Bool.Bool'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))
    data: True

    >>> rosmsgFalse = std_msgs.Bool(data=False)
    >>> marshalledFalse, errors = schema.dump(rosmsgFalse)
    >>> marshmallow.pprint(marshalledFalse) if not errors else print("ERRORS {0}".format(errors))
    {u'data': False}
    >>> value, errors = schema.load(marshalledFalse)
    >>> type(value) if not errors else print("ERRORS {0}".format(errors))
    <class 'std_msgs.msg._Bool.Bool'>
    >>> print(value) if not errors else print("ERRORS {0}".format(errors))
    data: False

    Load is the inverse of dump (if we ignore possible errors):
    >>> import random
    >>> randomRosBool = std_msgs.Bool(data=random.choice([True, False]))
    >>> schema.load(schema.dump(randomRosBool).data).data == randomRosBool
    True
    """
    data = RosFieldBool()


